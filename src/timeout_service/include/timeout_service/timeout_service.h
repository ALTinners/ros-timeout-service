#include <mutex>
#include <random>
#include <thread>
#include <chrono>
#include <regex>

#include <ros/service_client.h>
#include <ros/service_server.h>
#include <ros/node_handle.h>
#include <ros/publisher.h>
#include <ros/subscriber.h>
#include <ros/callback_queue.h>
#include <ros/this_node.h>
#include <ros/master.h>
#include <ros/publication.h>
#include <ros/topic.h>

class TimeoutServiceClient
{
    public:
        typedef uint64_t SessionId;

        TimeoutServiceClient()
            : eng_(std::random_device()())
        {}

        // TODO - figure out how this should work
        TimeoutServiceClient(TimeoutServiceClient&& other)
            : service_name_(other.service_name_)
            , nh_(other.nh_)
            , handles_lock_()
            , subscribers_(other.subscribers_)
            , publishers_(other.publishers_)
            , eng_(other.eng_)
            , distr_(other.distr_)
            , dispatch_lock_()
        {}

        template<class Service>
        static TimeoutServiceClient serviceClient(const ros::NodeHandle& nh, const std::string& service_name)
        {
            TimeoutServiceClient client;

            client.service_name_ = service_name;
            client.nh_ = ros::NodeHandle(nh.getNamespace());

            client.queue_ = ros::CallbackQueuePtr(new ros::CallbackQueue());
            client.nh_.setCallbackQueue(client.queue_.get());

            return client;
        }

        /**
         * @brief Call the service aliased by this handle with the specified request/response messages.
         * @note The request/response message types must match the types specified in the templated call to NodeHandle::serviceClient()/service::createClient()
         */
        template<class MReq, class MRes>
        bool call(MReq& req, MRes& res, const ros::Duration& timeout = ros::Duration(0.5))
        {
            namespace st = ros::service_traits;

            if (strcmp(st::md5sum(req), st::md5sum(res)))
            {
                ROS_ERROR("The request and response parameters to the service "
                            "call must be autogenerated from the same "
                            "server definition file (.srv). your service call "
                            "for %s appeared to use request/response types "
                            "from different .srv files. (%s vs. %s)", service_name_.c_str(), st::md5sum(req), st::md5sum(res));
                return false;
            }

            return call(req, res, st::md5sum(req), timeout);
        }

        /**
         * @brief Call the service aliased by this handle with the specified service request/response
         */
        template<class Service>
        bool call(Service& service, const ros::Duration& timeout = ros::Duration(0.5))
        {
            namespace st = ros::service_traits;

            if (!isValid())
            {
                return false;
            }

            return call(service.request, service.response, st::md5sum(service), timeout);
        }

        /**
         * \brief Mostly for internal use, the other templated versions of call() just call into this one
         */
        template<typename MReq, typename MRes>
        bool call(const MReq& req, MRes& resp, const std::string& service_md5sum, const ros::Duration& timeout = ros::Duration(0.5))
        {
            auto id = std::to_string(distr_(eng_));

            auto remove_handles = [this, id] {
                std::lock_guard<std::mutex> lock(handles_lock_);

                publishers_.erase(
                    std::remove_if(
                        publishers_.begin(),
                        publishers_.end(),
                        [id](const ros::Publisher& val) { return val.getTopic().find(id) != std::string::npos; }
                    )
                );

                subscribers_.erase(
                    std::remove_if(
                        subscribers_.begin(),
                        subscribers_.end(),
                        [id](const ros::Subscriber& val) { return val.getTopic().find(id) != std::string::npos; }
                    )
                );
            };

            try
            {
                bool has_response = false;
                {
                    std::lock_guard<std::mutex> lock(handles_lock_);

                    publishers_.emplace_back(
                        nh_.advertise<MReq>(
                            service_name_ + "/request/" + id,
                            0,
                            true
                        )
                    );

                    subscribers_.emplace_back(
                        nh_.subscribe<MRes>(
                            service_name_ + "/response/" + id,
                            0,
                            [this, &has_response, &resp, id](const typename MRes::ConstPtr& msg) {
                                std::cerr << "Got for " << id << std::endl;
                                resp = *msg;
                                has_response = true;
                            }
                        )
                    );

                    publishers_.back().publish(req);
                }

                auto start = ros::Time::now();
                while ( (ros::Time::now() - start) < timeout && !has_response )
                {
                    queue_->callAvailable();
                    std::this_thread::sleep_for(std::chrono::milliseconds(5));
                }

                remove_handles();

                std::cerr << "Was for " << id << "  - " << has_response << std::endl;
                return has_response;
            }
            catch(const std::exception& e)
            {
                ROS_ERROR("Error handling TimeoutService %s", e.what());
                remove_handles();
                return false;
            }
        }

        bool call(
            const ros::SerializedMessage& req,
            ros::SerializedMessage& resp,
            const std::string& service_md5sum,
            const ros::Duration& timeout = ros::Duration(0.5)
        );

        /**
         * \brief As "Non-persistent service handles are always valid." this interface is always true
         */
        bool isValid() const { return true; }

        /**
         * \brief isPersistent cannot be implemented as no guarantee can be made
         * The interface is provided for consistency
         */
        bool isPersistent() const { return false; }

        /**
         * \brief Shutdown the connection associated with this ServiceClient
         * Currently this method is not yet implemented
         *
         * This method usually does not need to be explicitly called, as automatic shutdown happens when
         * all copies of this ServiceClient go out of scope
         *
         * This method overrides the automatic reference counted shutdown, and does so immediately.
         */
        void shutdown();

        /**
         * \brief Wait for this service to be advertised and available.  Blocks until it is.
         * \param timeout The amount of time to wait for before timing out.  If timeout is -1 (default),
         * waits until the node is shutdown
         * \return true on success, false otherwise
         */
        bool waitForExistence(ros::Duration timeout = ros::Duration(-1));

        /**
         * \brief Checks if this is both advertised and available.
         * \return true if the service is up and available, false otherwise
         */
        bool exists();

        /**
         * \brief Returns the name of the service this ServiceClient connects to
         */
        std::string getService();


    protected:
        template<typename Service>
        void initialise_subscriber()
        {
            typedef typename Service::Response Response_t;

        }

        void handle_response(const ros::SerializedMessage& msg);

    private:
        std::string service_name_;

        ros::NodeHandle nh_;
        ros::CallbackQueuePtr queue_;

        std::mutex handles_lock_;
        std::vector<ros::Subscriber> subscribers_;
        std::vector<ros::Publisher> publishers_;

        std::mt19937_64 eng_;
        std::uniform_int_distribution<SessionId> distr_;

        std::mutex dispatch_lock_;

};

class TimeoutServiceServerHelper
{
    public:
        virtual ros::SerializedMessage handle(ros::SerializedMessage& request) = 0;
};

template<class MReq, class MRes>
class TimeoutServiceServerHelperT : public TimeoutServiceServerHelper
{
    public:

        typedef boost::function<bool(MReq&, MRes&)> Func_t;

        TimeoutServiceServerHelperT(const Func_t callback)
        : TimeoutServiceServerHelper()
        , callback_(callback)
        {}

        virtual ros::SerializedMessage handle(ros::SerializedMessage& serialised_request) override
        {
            MReq request;
            ros::serialization::deserializeMessage(serialised_request, request);
            MRes response;

            // TODO - what should the boolean response do here?
            callback_(request, response);

            return ros::serialization::serializeMessage(response);
        }

        const Func_t callback_;

};

class TimeoutServiceServer
{

    public:

        TimeoutServiceServer() {};


        template<class MReq, class MRes>
        static std::shared_ptr<TimeoutServiceServer> advertiseService(
            const ros::NodeHandle& nh,
            const std::string& service_name,
            const boost::function<bool(MReq&, MRes&)>& callback
        )
        {
            auto server = std::shared_ptr<TimeoutServiceServer>( new TimeoutServiceServer() );
            server->initialise<MReq, MRes>(nh, service_name, callback);
            return server;
        }

    protected:
        template<class MReq, class MRes>
        void update_topic_lists()
        {
            // std::cerr << (service_name_) << std::endl;
            std::regex re(service_name_ + "/request/([0-9]+)");
            ros::master::V_TopicInfo topic_infos;

            if (ros::master::getTopics(topic_infos))
            {
                topic_infos.erase(
                    std::remove_if(
                        topic_infos.begin(),
                        topic_infos.end(),
                        [&](const ros::master::TopicInfo& info) {
                            std::smatch m;
                            bool contains_id = std::regex_match(info.name, m, re);

                            auto itr = std::find_if(
                                subscribers_.begin(),
                                subscribers_.end(),
                                [&info](const ros::Subscriber& sub) {
                                    return sub.getTopic().find(info.name) != std::string::npos;
                                }
                            );

                            // std::cerr << "For " << info.name << " " << !contains_id << " " <<  (itr != subscribers_.end()) << std::endl;

                            return !contains_id || (itr != subscribers_.end());
                        }
                    ),
                    topic_infos.end()
                );

                for (const auto& topic_info : topic_infos)
                {
                    auto topic_name = topic_info.name;
                    std::cerr << "The topic is " << topic_name << std::endl;
                    subscribers_.emplace_back(
                        nh_.subscribe<MReq>(
                            topic_name,
                            0,
                            [this, topic_name, re](const typename MReq::ConstPtr& msg) {

                                std::cerr << "BUTTS FOR TEA" << std::endl;

                                std::smatch m;
                                std::regex_match(topic_name, m, re);
                                if (m.size() == 2)
                                {
                                    std::cerr << "MADES A PUB" << std::endl;
                                    std::string id = m[1].str();
                                    auto serialised_request = ros::serialization::serializeMessage(*msg);
                                    auto serialised_response = helper_->handle(serialised_request);
                                    auto now = ros::Time::now();
                                    MRes response;
                                    ros::serialization::deserializeMessage<MRes>(serialised_response, response);

                                    publishers_.emplace_back(nh_.advertise<MRes>(
                                        service_name_ + "/response/" + id,
                                        0,
                                        true
                                    ));

                                    publishers_.back().publish(response);

                                    std::cerr << (ros::Time::now() - now).toSec() << std::endl;
                                }
                                else
                                {
                                    ROS_ERROR("Regex no match - somehow");
                                }
                            }
                        )
                    );
                }
            }
            else
            {
                ROS_ERROR("Could not get master");
            }

            //Trim subscribers
            // subscribers_.erase(
            //     std::remove_if(
            //         subscribers_.begin(),
            //         subscribers_.end(),
            //         [](const ros::Subscriber& sub) { return sub.getNumPublishers() > 0; }
            //     ),
            //     subscribers_.end()
            // );
        }

        template<class MReq, class MRes>
        void initialise(
            const ros::NodeHandle& nh,
            const std::string& service_name,
            const boost::function<bool(MReq&, MRes&)>& callback
        )
        {
            nh_ = nh;
            service_name_ = service_name;
            helper_ = std::shared_ptr<TimeoutServiceServerHelper>(new TimeoutServiceServerHelperT<MReq, MRes>(callback));
            update_timer_ = nh_.createTimer(ros::Duration(0.01), [this](const ros::TimerEvent&) { update_topic_lists<MReq, MRes>(); });
            update_topic_lists<MReq, MRes>();
        }

    private:
        ros::NodeHandle nh_;
        std::string service_name_;
        ros::Timer update_timer_;
        std::vector<ros::Publisher> publishers_;
        std::vector<ros::Subscriber> subscribers_;

        std::shared_ptr<TimeoutServiceServerHelper> helper_;


};